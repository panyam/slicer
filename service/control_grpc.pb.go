// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package control

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// ControlServiceClient is the client API for ControlService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ControlServiceClient interface {
	//*
	// Returns information about a host as to which shards it (manually) hosts.
	GetTarget(ctx context.Context, in *GetTargetRequest, opts ...grpc.CallOption) (*Target, error)
	//*
	// Called to update a target (most likely its status).
	SaveTarget(ctx context.Context, in *UpdateTargetRequest, opts ...grpc.CallOption) (*Target, error)
	//*
	// Deletes/Removes a target - should also remove all associated shards.
	DeleteTarget(ctx context.Context, in *DeleteTargetRequest, opts ...grpc.CallOption) (*Target, error)
	//*
	// Return all hosts participating in this cluster.
	ListTargets(ctx context.Context, in *ListTargetsRequest, opts ...grpc.CallOption) (*ListTargetsResponse, error)
	//*
	// Get the source of truth/current snapshot of assignments of a shard key
	// to a set of handler addresses
	GetShard(ctx context.Context, in *GetShardRequest, opts ...grpc.CallOption) (*GetShardResponse, error)
	//*
	// Called by what ever is interested in notifying the controller of
	// updates to membership.
	SaveShard(ctx context.Context, in *SaveShardRequest, opts ...grpc.CallOption) (*SaveShardResponse, error)
	//*
	// Called by admin to delete a shard completely or particular targets for it
	DeleteShard(ctx context.Context, in *DeleteShardRequest, opts ...grpc.CallOption) (*DeleteShardResponse, error)
	//*
	// Shard clients (those who need to reach to a particular host that serves a shard)
	// will want to be notified when shard assignments have changed (failover, replicas,
	// rebalancing etc) so that they can reconnect.   This method provides a way for
	// clients to be notified when these have changed.
	Connect(ctx context.Context, opts ...grpc.CallOption) (ControlService_ConnectClient, error)
}

type controlServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewControlServiceClient(cc grpc.ClientConnInterface) ControlServiceClient {
	return &controlServiceClient{cc}
}

func (c *controlServiceClient) GetTarget(ctx context.Context, in *GetTargetRequest, opts ...grpc.CallOption) (*Target, error) {
	out := new(Target)
	err := c.cc.Invoke(ctx, "/protos.ControlService/GetTarget", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *controlServiceClient) SaveTarget(ctx context.Context, in *UpdateTargetRequest, opts ...grpc.CallOption) (*Target, error) {
	out := new(Target)
	err := c.cc.Invoke(ctx, "/protos.ControlService/SaveTarget", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *controlServiceClient) DeleteTarget(ctx context.Context, in *DeleteTargetRequest, opts ...grpc.CallOption) (*Target, error) {
	out := new(Target)
	err := c.cc.Invoke(ctx, "/protos.ControlService/DeleteTarget", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *controlServiceClient) ListTargets(ctx context.Context, in *ListTargetsRequest, opts ...grpc.CallOption) (*ListTargetsResponse, error) {
	out := new(ListTargetsResponse)
	err := c.cc.Invoke(ctx, "/protos.ControlService/ListTargets", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *controlServiceClient) GetShard(ctx context.Context, in *GetShardRequest, opts ...grpc.CallOption) (*GetShardResponse, error) {
	out := new(GetShardResponse)
	err := c.cc.Invoke(ctx, "/protos.ControlService/GetShard", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *controlServiceClient) SaveShard(ctx context.Context, in *SaveShardRequest, opts ...grpc.CallOption) (*SaveShardResponse, error) {
	out := new(SaveShardResponse)
	err := c.cc.Invoke(ctx, "/protos.ControlService/SaveShard", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *controlServiceClient) DeleteShard(ctx context.Context, in *DeleteShardRequest, opts ...grpc.CallOption) (*DeleteShardResponse, error) {
	out := new(DeleteShardResponse)
	err := c.cc.Invoke(ctx, "/protos.ControlService/DeleteShard", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *controlServiceClient) Connect(ctx context.Context, opts ...grpc.CallOption) (ControlService_ConnectClient, error) {
	stream, err := c.cc.NewStream(ctx, &ControlService_ServiceDesc.Streams[0], "/protos.ControlService/Connect", opts...)
	if err != nil {
		return nil, err
	}
	x := &controlServiceConnectClient{stream}
	return x, nil
}

type ControlService_ConnectClient interface {
	Send(*ControlRequest) error
	Recv() (*ControlMessage, error)
	grpc.ClientStream
}

type controlServiceConnectClient struct {
	grpc.ClientStream
}

func (x *controlServiceConnectClient) Send(m *ControlRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *controlServiceConnectClient) Recv() (*ControlMessage, error) {
	m := new(ControlMessage)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// ControlServiceServer is the server API for ControlService service.
// All implementations must embed UnimplementedControlServiceServer
// for forward compatibility
type ControlServiceServer interface {
	//*
	// Returns information about a host as to which shards it (manually) hosts.
	GetTarget(context.Context, *GetTargetRequest) (*Target, error)
	//*
	// Called to update a target (most likely its status).
	SaveTarget(context.Context, *UpdateTargetRequest) (*Target, error)
	//*
	// Deletes/Removes a target - should also remove all associated shards.
	DeleteTarget(context.Context, *DeleteTargetRequest) (*Target, error)
	//*
	// Return all hosts participating in this cluster.
	ListTargets(context.Context, *ListTargetsRequest) (*ListTargetsResponse, error)
	//*
	// Get the source of truth/current snapshot of assignments of a shard key
	// to a set of handler addresses
	GetShard(context.Context, *GetShardRequest) (*GetShardResponse, error)
	//*
	// Called by what ever is interested in notifying the controller of
	// updates to membership.
	SaveShard(context.Context, *SaveShardRequest) (*SaveShardResponse, error)
	//*
	// Called by admin to delete a shard completely or particular targets for it
	DeleteShard(context.Context, *DeleteShardRequest) (*DeleteShardResponse, error)
	//*
	// Shard clients (those who need to reach to a particular host that serves a shard)
	// will want to be notified when shard assignments have changed (failover, replicas,
	// rebalancing etc) so that they can reconnect.   This method provides a way for
	// clients to be notified when these have changed.
	Connect(ControlService_ConnectServer) error
	mustEmbedUnimplementedControlServiceServer()
}

// UnimplementedControlServiceServer must be embedded to have forward compatible implementations.
type UnimplementedControlServiceServer struct {
}

func (UnimplementedControlServiceServer) GetTarget(context.Context, *GetTargetRequest) (*Target, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTarget not implemented")
}
func (UnimplementedControlServiceServer) SaveTarget(context.Context, *UpdateTargetRequest) (*Target, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SaveTarget not implemented")
}
func (UnimplementedControlServiceServer) DeleteTarget(context.Context, *DeleteTargetRequest) (*Target, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteTarget not implemented")
}
func (UnimplementedControlServiceServer) ListTargets(context.Context, *ListTargetsRequest) (*ListTargetsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListTargets not implemented")
}
func (UnimplementedControlServiceServer) GetShard(context.Context, *GetShardRequest) (*GetShardResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetShard not implemented")
}
func (UnimplementedControlServiceServer) SaveShard(context.Context, *SaveShardRequest) (*SaveShardResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SaveShard not implemented")
}
func (UnimplementedControlServiceServer) DeleteShard(context.Context, *DeleteShardRequest) (*DeleteShardResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteShard not implemented")
}
func (UnimplementedControlServiceServer) Connect(ControlService_ConnectServer) error {
	return status.Errorf(codes.Unimplemented, "method Connect not implemented")
}
func (UnimplementedControlServiceServer) mustEmbedUnimplementedControlServiceServer() {}

// UnsafeControlServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ControlServiceServer will
// result in compilation errors.
type UnsafeControlServiceServer interface {
	mustEmbedUnimplementedControlServiceServer()
}

func RegisterControlServiceServer(s grpc.ServiceRegistrar, srv ControlServiceServer) {
	s.RegisterService(&ControlService_ServiceDesc, srv)
}

func _ControlService_GetTarget_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTargetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ControlServiceServer).GetTarget(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protos.ControlService/GetTarget",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ControlServiceServer).GetTarget(ctx, req.(*GetTargetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ControlService_SaveTarget_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateTargetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ControlServiceServer).SaveTarget(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protos.ControlService/SaveTarget",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ControlServiceServer).SaveTarget(ctx, req.(*UpdateTargetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ControlService_DeleteTarget_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteTargetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ControlServiceServer).DeleteTarget(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protos.ControlService/DeleteTarget",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ControlServiceServer).DeleteTarget(ctx, req.(*DeleteTargetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ControlService_ListTargets_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListTargetsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ControlServiceServer).ListTargets(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protos.ControlService/ListTargets",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ControlServiceServer).ListTargets(ctx, req.(*ListTargetsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ControlService_GetShard_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetShardRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ControlServiceServer).GetShard(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protos.ControlService/GetShard",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ControlServiceServer).GetShard(ctx, req.(*GetShardRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ControlService_SaveShard_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SaveShardRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ControlServiceServer).SaveShard(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protos.ControlService/SaveShard",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ControlServiceServer).SaveShard(ctx, req.(*SaveShardRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ControlService_DeleteShard_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteShardRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ControlServiceServer).DeleteShard(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protos.ControlService/DeleteShard",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ControlServiceServer).DeleteShard(ctx, req.(*DeleteShardRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ControlService_Connect_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(ControlServiceServer).Connect(&controlServiceConnectServer{stream})
}

type ControlService_ConnectServer interface {
	Send(*ControlMessage) error
	Recv() (*ControlRequest, error)
	grpc.ServerStream
}

type controlServiceConnectServer struct {
	grpc.ServerStream
}

func (x *controlServiceConnectServer) Send(m *ControlMessage) error {
	return x.ServerStream.SendMsg(m)
}

func (x *controlServiceConnectServer) Recv() (*ControlRequest, error) {
	m := new(ControlRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// ControlService_ServiceDesc is the grpc.ServiceDesc for ControlService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ControlService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "protos.ControlService",
	HandlerType: (*ControlServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetTarget",
			Handler:    _ControlService_GetTarget_Handler,
		},
		{
			MethodName: "SaveTarget",
			Handler:    _ControlService_SaveTarget_Handler,
		},
		{
			MethodName: "DeleteTarget",
			Handler:    _ControlService_DeleteTarget_Handler,
		},
		{
			MethodName: "ListTargets",
			Handler:    _ControlService_ListTargets_Handler,
		},
		{
			MethodName: "GetShard",
			Handler:    _ControlService_GetShard_Handler,
		},
		{
			MethodName: "SaveShard",
			Handler:    _ControlService_SaveShard_Handler,
		},
		{
			MethodName: "DeleteShard",
			Handler:    _ControlService_DeleteShard_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Connect",
			Handler:       _ControlService_Connect_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "service/control.proto",
}
